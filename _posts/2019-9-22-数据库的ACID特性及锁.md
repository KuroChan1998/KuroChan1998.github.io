---
layout:     post
title:      数据库的ACID特性及锁
subtitle:   关于ACID特性和mysql中锁的学习
date:       2019-09-22
author:     Kuro
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 数据库
    - mysql
    - ACID
    - 乐观锁
	- 悲观锁
	- 事务

---

# 数据库的ACID特性详解

> 事务(Transaction)是并发控制的基本单位。所谓事务，它是一个操作序列，这些操作**要么都执行，要么都不执行**，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。

数据库事务必须具备ACID特性，ACID是**Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）**的英文缩写。

## 基本概念

### 原子性（Atomicity）

一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，**不会结束在中间某个环节**。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。（oracle通过redo和undo日志保证）

### 一致性（Consistency）

事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。

**如果在事务中出现错误，那么系统中的所有变化将自动地回滚**，系统返回到原始状态。

### 隔离性（Isolation）

指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，**事务不会查看到中间状态的数据**。

### 持久性（Durability）

指的是只要事务成功结束，它对数据库所做的更新就必须**永久保存**下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。



​	事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统**采用日志来保证事务的原子性、一致性和持久性**。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。

​	数据库管理系统**采用锁机制来实现事务的隔离性**。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。

## 关于隔离性

### 在关系型数据库中几个关于读数据的概念

#### 脏读（Dirty Reads）

所谓脏读就是对脏数据（Drity Data）的读取，而脏数据所指的**就是未提交的数据**。也就是说，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，**第二个事务来读取这条没有提交的数据**，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。（oracle通过undo日志保证，读未提交的数据时，放回undo后的数据）

#### 不可重复读（Non-Repeatable Reads）

一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务**在两次读取之间该数据被其它事务所修改**。

#### 幻读（Phantom Reads）

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务**插入了**满足其查询条件的**新数据**，这种现象就称为幻读。

### 事务四个隔离级别：

#### 读未提交（Read Uncommitted）

SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）

#### 提交读（Read Committed）

只能读取到已经提交的数据。即**解决了脏读**，但未解决不可重复读。（**读锁**，等写完）

#### 可重复读（Repeated Read）

在同一个事务内的查询都是事务开始时刻一致的，**InnoDB的默认级别**。在SQL标准中，该隔离级别消除了不可重复读，但是**还存在幻读**。(写锁，等读完)

#### 串行读（Serializable）

完全的串行化读，所有SELECT语句都被隐式的转换成SELECT ... LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上3个均为行锁/记录锁，当前为表锁)

![20180809181059967 (1)](https://github.com/KuroChan1998/KuroChan1998.github.io/blob/master/img/mdimg/20180809181059967 (1).png?raw=true)

## 关于mysql乐观锁、悲观锁、共享锁、排它锁、行锁、表锁概念的理解

### 乐观锁

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在**操作数据时**，并不进行任何其他的特殊处理（也就是**不加锁**），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表**加一个版本(version)字段，每操作一次，将那条记录的版本号加1**。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先**判断此刻version的值是否与刚刚查询出来时的version的值相等**，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

举例：

下单操作包括3步骤：

1.查询出商品信息

```sql
select (status,status,version) from t_goods where id=#{id}
```

2.根据商品信息生成订单

3.修改商品status为2

```sql
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};
```

### 悲观锁

与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行**每次操作时都要通过获取锁**才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。**共享锁和排它锁**是悲观锁的不同的实现，**它俩都属于悲观锁的范畴**。

### 共享锁

指的就是对于多个不同的事务，**对同一个资源共享同一个锁**。

（这个例子不是我举的咳咳🥰）相当于对于同一把门，它拥有多个钥匙一样。就像这样，你家有一个大门，大门的钥匙有好几把，你有一把，你女朋友有一把，你们都可能通过这把钥匙进入你们家，进去啪啪啪啥的，一下理解了哈，没错，这个就是所谓的共享锁。

e.g.

```sql
SELECT * from city where id = "1"  lock in share mode;
```

对该记录更新

```sql
update  city set name="666" where id ="1";
```

此时，操作界面进入了卡顿状态，过几秒后，也提示错误信息

```
[SQL]update  city set name="666" where id ="1";
[Err] 1205 - Lock wait timeout exceeded; try restarting transaction
```

那么证明，对于id=1的记录加锁成功了，在上一条记录还没有commit之前，这条id=1的记录被锁住了，只有在上一个事务释放掉锁后才能进行操作，或用共享锁才能对此数据进行操作。

再执行：

```sql
update city set name="666" where id ="1" lock in share mode;
```

```
[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'lock in share mode' at line 1
```

加上共享锁后，也提示错误信息了，通过查询资料才知道，对于**update,insert,delete**语句会**自动加排它锁**的原因

于是，我又试了试

```sql
SELECT * from city where id = "1" lock in share mode;
```

这下成功了。

### 排它锁

排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。
与共享锁类型，在需要执行的语句后面加上for update就可以了

```sql
SELECT * from city for update
```

### 行锁

行锁，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。

比如之前演示的共享锁语句

```sql
SELECT * from city where id = "1"  lock in share mode; 
```

由于对于city表中,id字段为主键，就也相当于索引。执行加锁时，会将id这个索引为1的记录加上锁，那么这个锁就是行锁。

### 表锁

表锁，和行锁相对应，给这个表加上锁。

MyISAM引擎里有的。

## 参考

https://blog.csdn.net/puhaiyang/article/details/72284702